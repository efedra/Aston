//1) Какие бывают алгоритмы сортировок ?
// Пузырьком - Суть алгоритма в том, что сравниваются 2 соседних элмента. Если они стоят не на своих местах, то они меняются местами.
// Суть одного прохода - поставить самый старший элемент в конец. => каждый проход уменьшается на один элемент с конца
// Проход по массиву происходит до тех пор, пока элементы не будут на своих местах

// Выбором - Суть алгоритма в том, что мы поочередно находим наименьший элемент, сравнивая все элементы. Когда мы находим наименьший, то
//ставим его в начало массива и переходим на следующий проход, где начальный индекс будет уже 1, а не 0

// Вставками - Есть группы отсортированных и не отсортированных элементов. Изначально мы предполагаем, что первый элемент уже отсортирован, далее мы сравниваем
// следующий элемент неотсортированных элементов с последним элементом отсортированных. Если их не надо менять местами, то этот элемент добавляется в группу
// отсортированных, иначе мы начинаем сортировку отсортированного массива. Идем с конца, когда все элементы окажутся на своих местах, то мы добавляем
// элемент, который начал сортировку назад в группу отсортированных

// Хоара или быстрая- нужно выбрать один элмент относительно которого будут сортироваться все остальные. Например, посередине - опорный элемент.
//Далее создаем 2 указателя, которые ставятся на начало и конец(left и right) и они будут идти навстречу друг другу.
//Задача левого - найти элемент больший опорному. Задача правого - найти элемент меньший опорному. Когда они находятся, то меняются местами и указатели сдвигаются
// на один. Алгоритм нужно повторять до тех пор,пока left и right не перепрыгнут через друг друга и теперь нужно проделать теже шаги для каждого из подмассивов
//запуская рекурсию. Выход из рекурсии, когда массив будет из одного элемента.

// Ломуто - измененный Хоар. опорный элемент - последний. В левом массиве <= опорному, а правый массив СТРОГО меньше опорного, но не включая его
//Указатели начинают с одной строны - с первого элемента. Когда элементы находятся, то происходит их перестановка. после этого указатель left переместится на один вперед.
//Эти действия дают нам, что все элементы, которые СТРОГО меньше будут за указателем LEFT. поэтому мы можем сразу поменять опорный подмассив с Left.
// и мы передаем в рекурсию массив без поменянного элемента и опорного.

// 2) Прочитать про "Операторы и выражения, циклы в JS"
// те о которых не знала
//delete objName - удаление объекта, свойства объекта, или элемента массива с заданным индексом.

//instanceof - возвращает true, если заданный объект является объектом указанного типа. objectName instanceof objectType

//операторы нулевого присвивания(??=) x ??= y Оператор ??= присвоит x значение y только в том случае, если x не определено (null/undefined).

// операторы нулевого слияния(??) Результат выражения a ?? b будет следующим: если a определено, то a, если a не определено, то b.

// 3) Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person.
// Добавить метод logInfo чтоб он был доступен всем объектам.
let Person1Base = {
    name: "Ira",
    surname: "Fedorova",
    logFullName() {
        console.log(this.name + ' ' + this.surname)
    }
}
let Person1Child = Object.create(Person1Base) //1base
let Person2Child = Object.setPrototypeOf({}, Person1Base) //1base

function Person2Base(name, surname) {
    this.name = name
    this.surname = surname
}

Person2Base.prototype.logFullName = function () {
    console.log(this.name + ' ' + this.surname);
}

function Person3Child(name, surname) {
    Person2Base.apply(this, [...arguments])
}

Person3Child.prototype = Object.create(Person2Base.prototype);
Person3Child.prototype.constructor = Person3Child;
let Person3 = new Person3Child('Petua', 'Evtushenko');
Person3.logFullName()


class Person3Base {
    constructor(name, surname) {
        this.name = name
        this.surname = surname
    }

    logFullName() {
        console.log(this.name + ' ' + this.surname)
    }
}


//Классами
class Person4Child extends Person3Base {
    constructor(name, surname) {
        super(name, surname);
    }
}

let Child5 = new Person4Child("Oleg", "Crazy")
Child5.logFullName()

// 4) Создать класс PersonThree c get и set для поля name и конструктором, сделать класс наследник от класса Person.

class PersonThree extends Person3Base {
    constructor(name, surname, age) {
        super(name, surname)
        this._age = age
    }

    set age(value) {
        if (value < 18) {
            throw new Error('СЛИШКОМ МОЛОД')
        }
        this._age = value
    }

    get age() {
        return this._age + 5 + ' Немного соврем о возрасте'
    }
}

let PersonTheeEx = new PersonThree('Julia', 'Krap', 22)
console.log(PersonTheeEx.age)

// БОНУС:
// 1) Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
total = 13;
//result = [4, 9]

const firstSum = (arr, total) => {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] + arr[j] === total) {
                return [arr[i], arr[j]];
            }
        }
    }
    return [];
}

console.log(firstSum(arr, total))
//
// 2) Какая сложность у вашего алгоритма ?
// O(n^2)