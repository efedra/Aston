//1)Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает.

//Метод OPTIONS - это предварительный запрос, который  является одним из методов HTTP, который используется для определения
// возможностей сервера или параметров соединения для указанного ресурса.
// OPTIONS не имеет тело запроса, а ответ имеет тело. Является идемпотентным и не кешируется.
//- Когда вызывается: OPTIONS запрос отправляется клиентом для получения информации о поддерживаемых методах запроса, возможных заголовках, а также других параметрах, связанных с ресурсом.
// - Где используется: OPTIONS запрос часто используется в предзапросах Cross-Origin Resource Sharing (CORS) для проверки разрешений на выполнение запросов между разными источниками.
// - Что передает и принимает: OPTIONS запрос не передает тело запроса, а просто запрашивает информацию о ресурсе. Сервер в ответ может вернуть список поддерживаемых методов, заголовков, разрешенные методы доступа и другую информацию о ресурсе.
//
// Пример использования OPTIONS запроса:
fetch('https://api.example.com/resource', {
    method: 'OPTIONS'
}).then(response => {
        console.log(response.headers.get('Allow')); // Получение списка поддерживаемых методов
    });

//2)Прочитать и описать ключевые особенности "HTTP" Версии 3.0
//Использование протокола QUIC: HTTP/3 основан на протоколе QUIC (Quick UDP Internet Connections),
// который работает поверх UDP вместо TCP. Это позволяет уменьшить задержки и улучшить производительность передачи данных.
//В третьей версии, поскольку собрали новый протокол QUIC, обо всём хорошо подумали и рукопожатия свели к одному. В один
// запрос упаковали установление соединения и установление шифрования
// HTTP 3.0 был разработан в ответ на ограничения протокола TCP и для улучшения производительности передачи данных в сети.
// Основная причина перехода на HTTP 3.0 - это использование протокола QUIC (HTTP-over-QUIC), который предоставляет ряд значительных преимуществ:
//
// 1. Мультиплексирование потоков: QUIC позволяет мультиплексировать несколько потоков данных в одном соединении, что
// позволяет эффективно управлять каждым потоком отдельно и избежать блокировки начала очереди (Head-of-Line blocking).
//
// 2. Гибкий контроль перегрузки: QUIC обеспечивает более гибкий контроль перегрузки, что позволяет более эффективно
// использовать доступную полосу пропускания сети и повысить пропускную способность трафика.
//
// 3. Механизм восстановления после потерь: QUIC предлагает усовершенствованный механизм восстановления после потерь и
// прямое исправление ошибок, что помогает справляться с ошибочными пакетами и повышает надежность передачи данных.
//
// 4. Сжатие заголовков с помощью QPACK: HTTP/3 использует новый механизм сжатия заголовков - QPACK, который позволяет
// эффективно обрабатывать заголовки HTTP, поступающие не по порядку в разных потоках QUIC.
//
// 5. Улучшенный механизм push: HTTP/3 предлагает улучшенный механизм push для более эффективной доставки контента.
//
// 6. Быстрое установление соединения: Установление соединения происходит быстрее благодаря использованию QUIC, что
// сокращает задержку передачи данных.
//
// В отличие от комбинации TCP + TLS, где требуется два отдельных этапа для установления соединения и передачи данных, QUIC
// позволяет устанавливать соединение и передавать данные за одно обращение, что снижает задержку и улучшает производительность передачи данных в сети.

//3)Прочитать про способы отмены запроса, включая объект "AbortController"

//AbortController - это интерфейс, который позволяет контролировать отмену HTTP запросов на стороне фронтенда. Для
// взаимодействия с DOM запросами используется объект AbortSignal. Вызов метода abort() интерфейса AbortController прерывает запрос (например, Fetch запрос) до его завершения. Когда abort() вызывается, промис fetch() отклоняется с ошибкой AbortError.
//
// Для использования:
// 1. Создайте экземпляр контроллера с помощью конструктора AbortController().
// 2. Получите ссылку на связанный с ним объект AbortSignal через свойство AbortController.signal.
// 3. При инициализации fetch-запроса передайте AbortSignal в качестве параметра в объекте параметров запроса. Это ассоциирует
// ваш контроллер и сигнал с конкретным запросом, что позволяет остановить запрос с помощью метода abort().
//
// Для XMLHttpRequest также доступен метод abort(), который генерирует событие abort и устанавливает xhr.status в 0.

//4)Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number,
// boolean, null, undefined, symbol, bigInt)
let str1 = 'dsdada'
let str2 = String(213)
let str3 = true.toString()

let num1 = 123
let num2 = Number('321')
let num3 = parseInt('1234')
let num4 = 123.32
let num5 = parseFloat('123.321')

let bool1 = true
let bool2 = Boolean(0)

let nll = null

let undfnd = undefined

let symbol1 = Symbol('description');

const bigInt1 = 1234567890123456789012345678901234567890n;
const bigInt2 = BigInt(42);

//5)Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?
//Это происходит из-за того, что переменные, объявленные с помощью ключевых слов let и const, находятся в зоне видимости
// только после момента их объявления. Это называется "временной мертвой зоной" (Temporal Dead Zone).
// При обращении к переменным до их объявления в этой зоне возникает ошибка ReferenceError, потому что движок JavaScript
// не может найти значение этой переменной в данном контексте.

//6)
const res = "B" + "a" + (1 - "hello");
console.log(res); // "BaNaN

const res2 = (true && 3) + "d";
console.log(res2); //3d

const res3 = Boolean(true && 3) + "d";
console.log(res3); //trued